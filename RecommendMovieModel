# Recommend Movie

- Objetive: create a movie recommendation;

We are going to use the MovieLens dataset (https://grouplens.org/datasets/movielens/100k/). This dataset contains 100,000 ratings about movies. More about this dataset is founded in it README (https://files.grouplens.org/datasets/movielens/ml-100k-README.txt).

## First Steps -> Reading the dataset

Until today, I never dealt with dataset that did not have a 'showed' extension (for example: 'dataset.csv' or 'dataset.xlsx'). So, when I descompressed the dataset, I have a lot of archives that are describeb on README, but I have not found the format to read the data. Looking on google, I founded that this data is in 'csv' format, so, I will try read this.

# Imports
import warnings
warnings.filterwarnings("ignore")

import pandas as pd
import numpy as np

from random import sample

import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as plt_ticker
%matplotlib inline

from sklearn.neighbors import NearestNeighbors

data = pd.read_csv('/content/u.data')
data.head()

Seems to work! But, I need to arrange the data.
The data are separated by '/t' character and don't have a header.
We can use pandas again and add some parameters on 'read_csv' function.

data = pd.read_csv('/content/u.data', sep='\t', header=None)
data.head()

Looks better!
Now, I will put the header on dataset.
According to the README: *This is a tab separated list of user id | item id | rating | timestamp*. 
Go to next step!              

data = pd.read_csv('/content/u.data', sep='\t', header=None)

header = ['user_id', 'item_id', 'rating', 'timestamp']
data.columns = header
data.head()

Checking the data type

data.dtypes

Great! But 'timestamp' column doesn't make sense.
How this column are *unix seconds since 1/1/1970 UTC* (README.txt), we will convert those data.
Doing this is easy with pandas, using 'to_datetime' function.

data['date'] = pd.to_datetime(data['timestamp'].astype(int), unit='s')

# dropping 'timestamp' column
data.drop('timestamp', axis=1, inplace=True)

data.head()

I decided to create 'Year' columns, because I like to see some data by year.

data['year'] = data['date'].dt.year

Checking info about dataset

data.info()

Converting 'item_id' and 'user_id' to string

data['user_id'] = data['user_id'].astype(str)
data['item_id'] = data['item_id'].astype(str)

## Descriptive Statistics

data.describe(include='all')

So, now I finished my dataset and can go to explore data.

## Adding infos about movies

- Our dataset don't have the movie's title, the genres and other important infos. So, what we need to do is explore the additional data in https://grouplens.org/datasets/movielens/100k/ and add to our dataset.

- An interest data seems to 'u.item' dataset!

itens = pd.read_csv('/content/u.item', encoding='latin1', on_bad_lines='skip', sep='|', header=None)

The 'itens' dataset looks abstract, so let's go improve it.

Let's correct the header! (see the README)

header = ["movie id", "movie title", "release date", "video release date",
              "IMDb URL", "unknown", "Action", "Adventure", "Animation",
              "Children's", "Comedy", "Crime", "Documentary", "Drama", "Fantasy",
              "Film-Noir", "Horror", "Musical", "Mystery", "Romance", "Sci-Fi",
              "Thriller", "War", "Western"]

itens.columns = header
itens.head()

itens.info()

I will exclude column 'video release date' (all NaN values) and the column 'IMDB URL, because the IMDb link doesn't matter us now.

itens.drop(['video release date', 'IMDb URL'], axis=1, inplace=True)

Convert 'release date' to datetime

itens['release date'] = pd.to_datetime(itens['release date'])

Merging the dataset -> renaming the 'movie id' column from 'itens' dataset

itens.rename(columns={'movie id':'item_id'}, inplace=True)
itens['item_id'] = itens['item_id'].astype(str)
df = itens.merge(data, how='left')

df.describe(include='all', datetime_is_numeric=True)

- **Star Wars (1977)** was the most evaluated movie (583 evaluations);

- The **user_id 405** was one that gave more ratings (737 ratings);

- The mean rating was **3.529860** +/- **1.125674**.


## Exploring dataset

Release year

sns.countplot(data=df, x='year');

Checking the genres

genres = ['unknown', 'Action', 'Adventure', 'Animation', "Children's", 'Comedy', 'Crime',
       'Documentary', 'Drama', 'Fantasy', 'Film-Noir', 'Horror', 'Musical',
       'Mystery', 'Romance', 'Sci-Fi', 'Thriller', 'War', 'Western']

genres_dict = {}
for genre in genres:
 genres_dict[genre] = df.groupby(genre).count()['item_id'][1]

genres_df = pd.DataFrame.from_dict(genres_dict, orient='index', columns=['count']).sort_values(by='count')
genres_df

fig, ax = plt.subplots(figsize=(16,12))
plt.rcParams['font.size'] = '16'

ax.get_xaxis().set_major_formatter(plt_ticker.FuncFormatter(lambda x, p: format(int(x), ',')))
ax.barh(y=genres_df.index, width=genres_df['count'], color='gray')
right_side = ax.spines["right"]
right_side.set_visible(False)
top_side = ax.spines["top"]
top_side.set_visible(False)
ax.set_yticklabels(genres_df.index);
ax.set_xlabel('Genres Count');

Ratings

rating_df = pd.DataFrame(df.groupby('rating').count()['item_id'])
rating_df.rename(columns={'item_id':'count'}, inplace=True)

fig, ax = plt.subplots(figsize=(16,12))
ax.get_xaxis().set_major_formatter(plt_ticker.FuncFormatter(lambda x, p: format(int(x), ',')))
ax = sns.barplot(x=rating_df.index, y=rating_df['count'], orient='v', color='gray')
ax.set_yticks(np.arange(0,rating_df['count'].max()+5000, 5000))
ax.set_xticklabels(rating_df.index);
right_side = ax.spines["right"]
right_side.set_visible(False)
top_side = ax.spines["top"]
top_side.set_visible(False)

Ratings by User

rating_by_user = df.groupby('user_id').count()['rating']
rating_by_user.describe()

fig, ax = plt.subplots(figsize=(16,12))
ax = sns.histplot(rating_by_user, kde=True)
right_side = ax.spines['right']
right_side.set_visible(False)
top_side = ax.spines['top']
top_side.set_visible(False)
ax.set_xticks(np.arange(0,rating_by_user.max(), 50))
ax.set_xlabel('Distribution of Rating by User');

Rating by movie

rating_by_movie = df.groupby('movie title').count()
rating_by_movie.sort_values(by='rating', inplace=True, ascending=False)
rating_by_movie.head()

rating_by_movie['rating'].describe()

fig, ax = plt.subplots(figsize=(16,12))
ax = sns.histplot(rating_by_movie['rating'], kde=True)
right_side = ax.spines['right']
right_side.set_visible(False)
top_side = ax.spines['top']
top_side.set_visible(False)
ax.set_xticks(np.arange(0,rating_by_movie['rating'].max(), 50))
ax.set_xlabel('Distribution of Rating per Movie');

# Fonte: https://www.kaggle.com/code/saurav9786/recommender-system-using-amazon-reviews/notebook

fig = plt.figure(figsize=plt.figaspect(.5))
ax = plt.gca()
plt.plot(rating_by_movie['rating'].values)
plt.title('# rating per movie')
plt.xlabel('Movie')
plt.ylabel('No of ratings per movie')
ax.set_xticklabels([])

plt.show()

Plotting by ratings

- We can see more ratings in interval [3 - 4]

ratings_df = pd.DataFrame(df.groupby('movie title')['rating'].mean())
ratings_df['rating_counts'] = df.groupby('movie title')['rating'].count()
ratings_df.sort_values(by='rating', ascending=False, inplace=True)

sns.jointplot(x='rating', y='rating_counts', data=ratings_df, alpha=0.4, color='gray')
plt.show()

## Recommending movies by biggest ratings between 4 and 5

evaluate_rating = df[['movie title', 'rating']]
evaluate_rating = evaluate_rating[evaluate_rating['rating'] >= 4]

movie_rating = {}
for movie in evaluate_rating['movie title'].drop_duplicates():
  movie_rating[movie] = len(evaluate_rating[evaluate_rating['movie title'] == movie])

movie_rating_df = pd.DataFrame.from_dict(movie_rating, orient='index', columns=['count']).sort_values(by='count', ascending=False)
print(f"Recommended Films -> {list(movie_rating_df.head(10).index)}")

## Recommending movies by rating mean and rating counts

#new_df = df.groupby("movie title").filter(lambda x: x['rating'].count()>= 50)

We will use just movies with more evaluations than Q1 (7 evaluation)

new_ratings_df = ratings_df[ratings_df['rating_counts'] >= np.percentile(rating_by_movie['item_id'],25)]

## Recommending movies randomly

print(f'Recommend movies today: {sample(list(new_ratings_df.index),5)}')

## Recommending using kNeighbors

https://www.youtube.com/watch?v=Vkh2ay8hbbo&t=1352&ab_channel=labbme_in

df['user_id'] = df['user_id'].astype('int')

movie_user = df.pivot_table(index='user_id',columns='movie title',values='rating')
movie_user.fillna(0,inplace=True)
movie_user.head()

Create the model

knn_model = NearestNeighbors(metric='minkowski')
knn_model.fit(movie_user)

Reshape the data

user_index = 100

distance, index_neighbor = knn_model.kneighbors(movie_user.iloc[user_index].values.reshape(1,-1), n_neighbors=6)
index_neighbor

The movies will be recommended just if the rating was bigger than 4 and each neighbor will give 2 movies

def recommend_movie(user_index: int):
  user_index = user_index
  distance, index_neighbor = knn_model.kneighbors(movie_user.iloc[user_index].values.reshape(1,-1), n_neighbors=6)
  recommended_movies = []

  for neighbor in index_neighbor.flatten():
    if neighbor == user_index:
      pass
    else:
      c = 0
      for movie in df[(df['user_id'] == neighbor) & (df['rating'] >= 4)]['movie title']:
        recommended_movies.append(movie)
        c += 1
        if c >= 2:        
          break

  if len(recommended_movies) == 10:
    i = 0
    j = 1
    while i < len(recommended_movies):
      j = i + 1
      while j < len(recommended_movies):                
        if recommended_movies[i] == recommended_movies[j]:
          del(recommended_movies[i])                        
          j += 1
        else:
          j += 1  
      i += 1

  while len(recommended_movies) < 10:
    new_df = df[(df['user_id'] == index_neighbor.flatten()[1]) & (df['rating'] >= 4)]
    new_df.set_index(np.arange(len(new_df)), inplace=True)
    num = sample(range(2, new_df.index.max()),1)
    recommended_movies.append(new_df.loc[num]['movie title'])

  return recommended_movies 

recommend_movie(50)
